/*
This is a standard MCM question, but the reason it might have been marked as a HARD could be that we would need to pad an index before and an index after the array size 
with 1 to do the MCM operation.
else just follow the standard MCM template.
For the base case if the variable i points next to j , we would return 0 signalling no elements are left in between
*/

class Solution {
public:
    int helper(int i, int j, vector<int>& nums, vector<vector<int>>& dp) {
        if (i + 1 == j) return 0; 
        if(dp[i][j] != -1){
            return dp[i][j] ; 
        }

        int ans = 0;
        for (int k = i + 1; k < j; k++) {
            int coins = nums[i] * nums[k] * nums[j]
                      + helper(i, k, nums, dp)
                      + helper(k, j, nums, dp);
            ans = max(ans, coins);
        }
        return dp[i][j]=ans;
    }

    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<int> values(n + 2, 1);
        for (int i = 0; i < n; i++) values[i + 1] = nums[i];
        vector<vector<int>>dp(n + 2, vector<int>(n + 2, -1)) ; 

        return helper(0, n + 1, values,dp);
    }
};
