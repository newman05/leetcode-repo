/*
Standard Binary Search on answer space problem, we need to focus on the finding the optimal end index for a particular interval. 
We can do so by sorting the array on the basis of its starting index, whilst storing its original index with it as well.
Time compleixty = O(n) + O(nlogn) + O(nlogn) ==> O(nlogn)for sorting and applying bs while iterating on the intervals.
Space complexity = O(n) 
*/

class Solution {
public:
    vector<int> findRightInterval(vector<vector<int>>& intervals) {
        int n = intervals.size() ; 
        int cnt = 0 ;
        vector<int>res(n , -1) ; 
        vector<pair<int , int>>v ; 

        for(int i = 0 ; i <n; i++) {
            v.push_back({intervals[i][0] , i}) ; 
        }

        sort(v.begin() , v.end()) ; 

        for(int i = 0  ;i < n ; i++) {
            int l = 0 ;
            int r = n - 1 ; 
            int tg = intervals[i][1] ; 

            while(l<=r) {
                int mid = (l + r)/ 2; 
                if(v[mid].first >= tg) {
                    r = mid - 1 ;
                    res[i] =v[mid].second; 
                }
                else {
                    l = mid + 1 ;
                }
            }
        }
        return res ; 
    }
};
