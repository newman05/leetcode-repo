/*
the initial approach would be to use a max heap, extract the top 2 elements, do the operation of steps on them and push them back in the heap. However considering the 
input constraint, this would give TLE. Though in interviews where constrains might not be revealed until later, this should be the primary approach.

One observation I can make here is that 1-3 requires = 1step , 4-15 requires= 2, 16-63=3steps and so on. this gives me the basic segmentation of steps.
I can use this and work on each query.

The only case to consider is if one query has elements lying in multiple ranges.
In that case find the min of the right boundary and operate on that (R = 4*L -1) 
and then increase the steps (S +=1), to work on the next boundary.
*/

class Solution {
public:

    long long solve(int l , int r) {
        long long L = 1 ; 
        long long S = 1 ; 
        long long ok = 0 ;

        while(L<= r){
            long long R = 4*L - 1; 

            long long start = max(L , (long long)l) ; 
            long long end = min(R , (long long ) r) ; 

            if(start <= end) {
                ok += (end - start+ 1)* S; 
            }
             S+=1 ; 
             L = L * 4 ; 

        }

        return ok ; 
    }

    long long minOperations(vector<vector<int>>& queries) {
        
        long long cnt = 0 ; 
        for(auto &query : queries) {
            int l = query[0] ; 
            int r = query[1] ; 

            long long ok = solve(l , r) ;

            cnt += (ok + 1) /2 ; 

            
        }

        return cnt ; 
    }
};
