/*A DSU question. The idea is divide the graph in different components using find and Union. then would map those components, to the find the size of each components.
Next up , we will use the formula==> result = result + (size) * (remaining_size - size) to calculate the unreachable pairs. then we update the remaining_size = remaining_size - size ;
we start the remaining_size as eqauls to n.  
*/


class Solution {
public:
    vector<int>parent , rankv ; 
    int find(int x) {
        if(x == parent[x]) {
            return x ; 
        }

        return parent[x] = find(parent[x]) ; 
    }

    void Union(int x , int y) {
        int x_parent = find(x) ; 
        int y_parent = find(y) ; 

        if(x_parent == y_parent) {
            return ; 
        }

        if(rankv[x_parent] < rankv[y_parent]) {
            parent[y_parent] = x_parent ; 
        }
        else if(rankv[y_parent] < rankv[x_parent]) {
            parent[x_parent] = y_parent ; 
        }
        else {
            parent[x_parent] = y_parent ; 
            rankv[x_parent]++ ; 
        }
    }

    long long countPairs(int n, vector<vector<int>>& edges) {
        parent.resize(n) ; 
        rankv.resize(n  ,0) ; 

        for(int i = 0; i < n ; i++) {
            parent[i] = i ; 
        }

        for(auto& vec: edges) {
            int u = vec[0] ; 
            int v = vec[1] ; 
            Union(u , v) ; 
        }

        unordered_map<int , int> mpp  ;
        for(int i= 0 ; i < n ;i++) {
            int pp = find(i) ; 
            mpp[pp]++ ; 
        }

        long long cnt = 0 ;
        long long rem = n ; 

        for(auto it : mpp ) {
            long long ok = it.second ; ;

            cnt += (ok) * (rem -ok) ; 

            rem = rem - ok ; 
        }

        return cnt ; 



    }
};
