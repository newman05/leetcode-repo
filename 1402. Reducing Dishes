// Leetcode hard, not due to the fact that the question is itself hard, but the fact that it has multiple solutions to it.
// 2 approaches 

// Recursion 
class Solution {
public:
    int helper(int i, int time, vector<int>& satisfaction) {
        if (i == satisfaction.size()) {
            return 0;
        }

        int take = satisfaction[i] * time + helper(i + 1, time + 1, satisfaction);

        int notTake = helper(i + 1, time, satisfaction);

        return max(take, notTake);
    }

    int maxSatisfaction(vector<int>& satisfaction) {
        sort(satisfaction.begin(), satisfaction.end());  
        return helper(0, 1, satisfaction);  
    }
};
// this solution will TLE due the input size, hence I will optimize it by dp

// DP solution (0-1 Knapsack logic)
class Solution {
public:
    int dp[505][505];
    int helper(int i, int time, vector<int>& satisfaction) {
        if (i == satisfaction.size()) {
            return 0;
        }
        if(dp[i][time] !=-1) {
            return dp[i][time] ; 
        }

        int take = satisfaction[i] * time + helper(i + 1, time + 1, satisfaction);

        int notTake = helper(i + 1, time, satisfaction);

        return  dp[i][time] =  max(take, notTake);
    }

    int maxSatisfaction(vector<int>& satisfaction) {
        sort(satisfaction.begin(), satisfaction.end()); 
        memset(dp, -1, sizeof(dp));
 
        return helper(0, 1, satisfaction);  
    }
};
// will get accepted, but a follow up more optimized approach maybe asked.


// Greedy solution, beats 100% runtime
class Solution {
public:
    int maxSatisfaction(vector<int>& satisfaction) {
        sort(satisfaction.rbegin(), satisfaction.rend());
        int total = 0, current = 0;

        for (int val : satisfaction) {
            total += val;
            if (total < 0) break;  
            current += total;
        }

        return current;
    }
};
